# Battle Resource Test

Wow. Episode Five of the Symfony Rest Tutorial – you are killing it. This is a special tutorial for me because I’m going to talk about things that we haven’t talked about yet, the things that really confused me and tripped me up when I started building Rest tutorials because there are a lot of buzzwords out there like Hypermedia, HATEOAS; making decisions between post and put and item potency. A lot of those details are important, but a lot of those details are not important. It’s difficult to know what decisions to make when you’re building your API. So, we’re going to go directly after those tough topics today and hopefully clear everything up.

As always, download the code to code along with me. Unzip the file and move into the start directory. I already have the start directory here in this symphony-rest directory. If you’ve been coding along before, download the new code because I made a couple of small changes to the project between now and the previous course. 

When you’ve got the code, let’s run the built-in web server with /bin/console server: run. Make sure you also open the Read Me file because there are a few extra setup instruction inside there. Okay. Let’s pull up the web front of our website at localhost:8000. As always you can log in with weaverryan, password foo. Now, here’s what we’re looking at. So far we’ve created a wonderful API for doing everything with a programmer. A programmer is our first API resource, but now we’re going to have a second API resource, a battle. And I want you to watch how it works on the web.

So, step one is I choose a programmer so I already have a programmer here.  Once I have a programmer I hit start battle. These three things here are projects. They are also actually an API resource. It’s not a resource that we have any end points for, but they are products in the API. 

So, to create a battle we have a programmer and we have a project and then when we select them some really cool stuff happens in the background and; boom – we end up with a brand new battle resource between our programmer in that project and it determines if we won. The battle resource is going to be very critical because its very existence is predicated on it being related to other resources. It’s related to the programmer resource and it’s related to the project resource. It turns out that relating things in an API is sometimes where things get tricky.

In the entity directory of our project we can see our programmer resource that we’ve been working on and we can also see the project entity which just has a name and a difficulty level. It’s very straightforward and we’re going to ignore it for the most part. And then you can see the battle resource, which is related to a programmer. Do you see I have a many-to-one doctrine relationship? It’s related to a project and also has a couple of other fields like DidProgrammerWin, foughtAt, and Notes. 

So, I want to add an end point to our API so I can initiate battles just like we did on the web interface. As always we’re going to start with the test because that’s our opportunity to design what our API should like. So, in the same controller API test directory let’s put a new battler controller test class and make it extend that same API test case that we’ve done before. And I’ll create public function TestPostCreateBattle. 

For the most part we know how this should work. We know that Post should be used to create resources. We know that a 201 status code should be returned, so let’s start down that same direction. Open up Programmer Controller Test and at the top copy this setup method which creates a user. We need that because all of our end points are going to be secured so we’re going to need to log in. You’ll see how we use that in a second to create a valid authentication token.

Okay. So, thinking about the API there are only two pieces of information we need to send to the server to create a battle. We need to send which programmer is in the battle and which project is in the battle. So before we start we need to create those in the data best. So, let’s start with project =this->createProject and give it a name of my_project. That doesn’t matter. This creates project method, if you hold command and click under that, that was in the API test case. I created that in the background. It just creates the document’s persistency and flushes to the database. 

Next, let’s create a programmer. A programmer =$this->createProgrammer. This takes an array of information about that programmer. Let’s give it a nickname of Fred. The second argument to create a programmer is the users that should own that. We want that to be owned by weaverryan because that’s who we’re going to authenticate as – awesome.

So, next we’re obviously going to send JSON data up to the server. In programmer controller tests it was pretty easy because we just had these three scaler fields: nickname, avatar number, and tagline. But now it’s a little different because we actually want to identify a related object, the related programmer object, and the related project object. So, how do we do that? Do we send up the ID? Do we send up the programmer’s nickname? And the answer is; it doesn’t really matter, but yeah basically you’re just going to send up the project ID and you’re going to send up the programmer ID.

So, let’s create a data array. We’ll have two fields: project – we’ll do project, getID and the programmer set to programmer, getID. I’m not using project and programmer keys for obvious reasons, but those could be anything. We’re in charge of calling our fields whatever we want in our API.

And finally, let’s make the post request. So, response=this->client, which is the guzzle client we have set up, ->post and then for the URL: for the programmers we’re using /API/programmers, so let’s keep consistent with that and make this /API/battles. Pass an array to the second arguments and to send the JSON body, add a body key set to json_encode($data) and we also need to send our authorization header, so add a headers key and then we’ll use a shortcut we made in the previous episode called this->get authorization headers weaverryan, so that will send a valid JSON web token authorization header for weaverryan so that we’re authenticated as that user.

Whew, okay. That’s it. Even though we are creating an object that is related to other objects it works pretty much like a normal API expect that we send the IDs up for those related projects. So, what should we assert? Well, let’s just do some basics right now: assertEquals that status code should be 201 because we’re creating something and let’s also assert that at least until we get that we at least get back one of the valid fields on the battle entity. One of the fields is called DidProgrammerWin. Of course when we create this battle, the response will be a representation of that battle resource, so very simply it will return the fields on the battle.

So, say this-> asserter ->ResponsePropertyExists and look for the DidProgrammerWin. We don’t know if that’s going to be true or false. That doesn’t matter. Let’s just make sure that it actually exists.

And then a little to do for later: another thing that we always look for when we create a resource is a location header that points to the URL where we can view this new resource. Well, we don’t have a show end point to view a single battle yet, so we’re not going to be able to fill this in yet, but I am going to put a little assertTrue for response->HasHeader location, but I’m going to comment that out.  

And that’ it – that’s the hardest work. We now have our API designed, so I’m going to copy the name of that method, open up a new tab, run vendor, then php unit, -- filter, and paste that. Hopefully we should get a nice 404. Awesome – there’s the 404. So, let’s get to work on this.
