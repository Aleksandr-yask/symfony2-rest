# API Relations Inform

Let's get to work. Inside the controller\api directory, let's create our new battle controller. Setting this up is going to be easy. We're going to send our same base controller that we've been using in every other controller, which has some nice shortcuts for us. And then we'll create the public function new action. And above it, add the @route and I'll hit tab to autocomplete that for \api\battles. You really want this to be a post method, so add @method and also hit tab to autocomplete that and then post. Awesome. 

Okay. Normally, we process our form submission through a form. You can see this inside of programmer controller. This form directly modifies the entity that we want to save to the database. However, this is not as simple and let me show you why. On the front end, we already create battles. And to do that, we have a service class called battle manager. It has a battle function and we give it a programmer object and a project object and it creates the battle in this central location and does some logic to figure out who won. 

Because we have it set up this way, when I built the original battle entity, I actually gave it a construct function that takes in a programmer object and a project object, and I kind of like that. So here's the problem. When you use Symphony's form system, it wants to instantiate your battle object. Normally, it uses these setter functions to put the data on it. This means that, unless I change my battle entity, I can't use it directly with a form object as it's going to fail to instantiate the object. There is a way to handle this with something called data mappers, but it's just not worth it. I actually like this complication because it shows off a very easy workaround. 

Whenever your form doesn't match your entity – maybe because your field names are different or because of a complicated situation like this – just create a new class and bind that to your form. Let me show you what I mean. In the form directory, create a model directory to keep things organized, and inside of there a new PHP class called a battle model. Give these two properties – project and programmer. Now hit command+N, or the code generate menu, and generate the getters and setters for both of those, so that this will work really nicely with the form. 

And just to be extra safe, I'll type in set programmer with the programmer and set project with project. Now we do have an object that will work really nicely with the form system. This won't get persistent to the database, but we can use it to create the real battle entity quickly. 

Now that we have this, let's create our form class. In the form directory, let's create a new PHP class called battle type. Make this extend the normal abstract type from the form system. And then I'll go back to the code generate menu, or command+N, and go to override methods and we're going to want to configure the build form method and the configure options method. You can take out the parent combo to those because the parent methods are empty. 

Okay, let's think about this. We're sending up a programmer field and a project field. We're sending up the IDs, but ultimately we want those to turn into objects. After all, that's how I built this battle model. The set project and the set programmer, I want those to be objects and not just the IDs. It turns out this is exactly what the built in entity type does. So build your form with builder arrow @project and set this to entity type::class. And this will require one option, which is the actually class we want to query from. So we'll set that to @bundle\entity\project. 

And let's copy that and do the exact same thing for programmer. A field called programmer – and this will give me a programmer class. Normally, this is what makes a drop down in a normal form, where it displays the project and the programmer. But in an API, it actually works in a really cool way. If we set a project ID, it will transform that into a project object and actually call set project with that project option. So it's exactly what we want. 

Configure options, call set defaults, and there are two things we need to give it – the all-important data class. We'll send that to battle model::class to use the new PHP 5.5 shortcut. Make sure you have a use statement for that battle model class – that last auto completion. I just did it out of that. And then we also need to turn off CSRF protections. CSRF protection set to false because we can't use normal CSRF protection in an API. There are ways to do that in an API, but it's a totally different topic. 

Alright. Form is ready. So finally, let's hop into our controller and do the same flow that we always do. Step one, create a battle model object. Battle model equals new battle model – and then create a form object. The form equals this arrow, create form – and we will use battle type::class. And the same thing. I'm going to go back and retype the E and autocomplete that so it adds the use statement on top. That's not super smooth right now. The second argument to create form, give it the actual battle model object. 

Second, this arrow process form, we need to pass up the request object and the form object. As a reminder, if you hold command and go into process form, this is something that lives in our base controller. It decodes the body off of the request and it submits those fields into the form. So it's just a nice little shortcut. Type in the request object from HTB [07:19] foundation to get that as an argument and then pass request and then pass it the form object. 

So at this point, the form is bound. If it's not valid, then we need to send it back in read errors, and we also have a method for doing that already. We're going to say this arrow, throw API problem validation exception. And if you pass it the form object – we've already done the work for this in previous episodes – that will return a nice JSON response with the form errors. 

Okay, we're killing it. Let's finish this up. We now have a battle model object which is populated with the programmer object and the project object that's related to it. Now we can finally use that battle manager I was showing you before, to have it create and save the battle entity for us. So, say this arrow get battle manager – again, a hold command – just a shortcut to get that service out of the container, arrow, battle. And pass it battle model arrow get programmer and battle model arrow get project – and that's it. Put a little battle equals in the beginning of this because that is our saved battle object. 

And that is what we want to return from our API response. So return this arrow create API response – yet another shortcut method we've created in previous episodes, and pass that battle in the 201 status code. We'll even add a little note above this that says to do set the location header once we have an end point that shows a single battle. And that is it. Controller model form. Everything else is reusing logic from before. So let's try our test. Run it – it passes. Awesome. 

So now let's start playing around with this end point and the relations and see some other cool stuff we can do. 
