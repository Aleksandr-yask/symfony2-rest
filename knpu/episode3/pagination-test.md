# Pagination Test

Hey, Guys.  Welcome to Episode 3 of our Rest and Symfony Series.  In this episode, we’re gonna cover some kind of – we’re gonna cover some things – some really important details we haven’t talked about yet, like pagination, filtering, and taking the serializer and doing really custom things with it.  

And first, we’re gonna talk about pagination.  If you’re following along with me, we’re gonna use the same project we’ve been using.  Same project we have been using, and you can download this off of our site and go into start directory, and we’re gonna add console server run to get that going.  

Now, let’s talk about pagination because right now, our slash API slash programmers endpoint doesn’t have it.  And eventually, we’re gonna have a lot of programmers in here and we are not going to be able to return all of them.  So first, think about pagination on the web.  How does it work?  Well, usually it’s done with query parameters.  So we have things like question mark page equals one, page equals two, page equals three, and so forth.  You can also do it as slash three, slash four, slash five, but query parameters are a good bet.

The second important thing is that they’re done – is that we don’t make the user guess those URLs, we give them links.  So we’re used to having a ‘next’ link and a ‘previous’ link.  Sometimes we also have a ‘last’ link and a ‘first’ link.  So in API, it’s gonna be exactly the same.  We’re gonna use query parameters, and we’re gonna use links to help the user get around.

So, like always, we’re gonna start with our test and it’s gonna help us design exactly how we want this to look.  So in Programmer Controller Test, I’m gonna go down and find my Test Programmers Collection.  I’m gonna copy this and make a new one for pagination.  Now, to make this interesting, we’re gonna create 25 programmers, so I’ll do a for-loop, for ‘i’ equals zero, ‘i’ less than 25, ‘i’ plus plus, and we’ll call a create programmer inside of there each time, and we’ll call each programmer programmer plus ‘i’, so programmers zero through 24 and the avatar number doesn’t matter.  

The URL’s still the same.  The assert 200 is good.  And down here, I’m gonna want to assert first that programmers index five nickname is equal to programmer five.  I’ll spread this onto multiple lines.  So five being the sixth programmer, we have programmers at zero, one, two, three, four, five, so the sixth one is actually programmer five.  And that’s already how things work now.

In addition to links, a lot of times on the web, it will also tell you how many you’re seeing on a specific page, like ten results on this time, and it will also tell you how many results there are.  So, ten showing on this page out of 500.  So let’s do the same thing here.  Let’s assume – and it’s not of our API.  So let’s have a property called count, which will be the number we want per page, and then our API, let’s use ten per page.  And let’s have another one called total, which will be the total number of results, which we know in this case is going to be 25.

And the last thing we need to worry about are those links I keep talking about.  I don’t want the user to have to guess how to get to the next page.  Instead, let’s embed a field inside of our API endpoint that says, “The next page is this URL.”  So I’m gonna use the asserter again.  I’m just gonna change this to ‘assert response property exists’.  Let’s assert that there is an underscore links dot next.  The next part should make a lot of sense.  And underscore links is just my way of separating what we can think of as data from the data from this field, which is not data but it’s a link.  Oh, and you probably saw, actually, my field above that actually says total, not count.

So what’s cool about this now is that we can just grab this link, and just follow it to the next page, and in our test, that’s what I want to do.  So next URL equals this, asserter, and we can use a method called read response property, and get that underscore links dot next property off of there, and now, we’ll just say response equals client, this get client – this, arrow client, arrow get, next URL, to follow onto the next page.  

Now, let’s do some more tests on this page.  All right, I’ll copy a bunch of these things up here – copy a bunch of the reasserts that we just wrote.  This time, programmer index five should actually be programmer 15 because we’re looking at results 11 through 20.  Down here, the count should still be ten because there is still ten, and total should still be 25, but let’s go ahead and remove that.  Okay, so this is doing a next link.  We’re gonna want a previous link, and I’m also gonna have a first link and a last link.  So let’s do one more thing where we actually click the last URL.  

What is going on with my formatting here?  And now, let’s print the last URL.  So look for underscore links dot last, which the next URL in this case would also be the same as the last URL.  And we will make a get request of that, and this time, programmers four will be the last one because it’s zero through – index zero through 24, and now we programmer 24.  Account should be five, and I’m also gonna use the asserter just to say this asserter – assert response property does not exist, to make sure we don’t have a programmer index five here.  So response, and what should not exist is we should not have a programmer five dot nickname.  In fact, we shouldn’t even have a programmer’s five key, but there’s a little – if I do a limitation in Symfony’s property path, when you check – if you’re checking for the – if you’re checking to see if a property exists, go all the way down to call something on the object itself.

And now that we have – so our – so our – the way we’re gonna paginate is really well-defined now.  So in the next chapter, we’re gonna actually make this work.
