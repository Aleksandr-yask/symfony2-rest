# Pagerfanta Pagination

Hammock pagination (0:00) we’re going to install the Whiteoctober Pagerfanta Bundle. Well, it’s not a bundle. 

Sites/symfony-rest$ composer require white-october/pagerfanta-bundle

So now (0:21) you can finally use to just integrate into (0:24) Pagerfanta library in the symfony, which is a nice library to use for pagination, whether you’re using things on the web, or you’re doing things in the API. 

While we’re waiting, I’m going to enable this bundle. Fortunately, that's really it for this library. You don’t need any configuration. You can just start using it. 

Awesome.

Choose a popular controller. Let’s find the list of action that we're targeting. So pagination is pretty easy. You basically need to tell the pagination library what page you’re on and give it a query builder. And then you can use to generate the correct results. So you get to the page, just type in the request argument. And against, you use the query power so to say, your 

$page = $request->query->get (‘page’, 1); 

and we’ll leave it to default by 1 after “is not”. For the query builder… the query builder under your place as programmers where you’ll go, (2:35) instead of trying to find it, I’m going to call a new method called

->findAllQueryBuilder()

does not exist yet. So I’ll hold command here, how to take minimal repository(2:49). Let’s go ahead and create that.

public function findAllQueryBuilder(|)

which for now does 

return $this->CreateQueryBuilder(‘programmer’);

and then give it some alias about programmer. And that’s it, perfect. So now we’re dangerous
and we can get right into the Pagerfanta stuff. So start with saying

$adapter = new DoctroneORMAdapter($qb);

since that’s what we using, and pass it your query builder. Now I create the 

$pagerfanta = new Pagerfanta($adapter);

liberating (3:29) new Pagerfanta and passing it back and that (3:31) adapter. On the Pagerfanta orbit page (3:34), I’m going to call 2 methods.

$pagerfanta->setMaxPerPage(10);

Sets are 10 which we’re just choosing, and

$pagerfanta->setCurrentPage($page);

which is $page.

What we need from the Pagerfanta is what program should be showing right now based on whether we’re on page 1, 2 or 3. To get that, when we use that method on 

$pagerfanta->getCurrentPageResults() 

But instead of returning it an array of programs, because every turn this traversable object which you need to throw that in, the serializer kind of confuses things. Because a serial kind of confuses because the serializer doesn’t know how to look on the specific programmers on that object. So instead, we’re going to create a new programs op. So all you need to do is create a new programmers array.

$programmers = array();

And then we’re going to foreach over those results, hence pop them into that array.

foreach ($pagerfanta->getCurrentPageResults() as $programmer) {
	$programmers[] = $programmer;
}

So that kind of clean things up if you want.

And now we’re going to get chip (5:00). For API responsible subpassive (5:05) programmers, sometimes in the programmer's’ keyboard, we also want to have a count, a total, and a count key.

$response = $this->createApiResponse([

So I’ll say

‘total’ => $pagerfanta->getNbResults(),

The total number results. And for our short (5:30) count, that’s easy. That’s just a count of the number of programs which you’re sharing right now, which you’re going to say count programmers.

‘count’ => count($programmers),
‘programmers’ => $programmers,
]);

And this should be enough to get us through page one. So let’s try our test.

./bin/phpunit -c app -- filter testGETProgrammersCollectionPaginated

and let’s grab the method name that we want to run and just throw it in there.

You don’t expect this to surpass because there’s no links. It shouldn’t pass yet, but if you look, we do have pagination 0 through 9. And it just dies when it tries to read the property “_links.next” because we don’t have any of the links yet. But pagination check, just nude without links yet. But we can make 1 improvement on this. We’re prying a new page national lot(6:19) so instead of returning this structure with these 3 keys, why not create an object that we can actually put the data into, and then let the serializer serialize that object in the same way that we serialize our entities. 

So I’ll create a new directory called Pagination. Inside of that, a new PHP class to model this called PaginatedCollection. Make sure it’s in the page AppBundle\Pagination namespace. Very simply, we’ve give this 3 properties. Items, total and count. 3 properties that we want on our collection.

class PaginationCollection
{
	private $items;
	private $total;
	private $count;
}

Inspect the constructor and move past in items and the total. Now as for total, we don’t need the count because again we can set 

$this->count = count($items);

and we’re in good shape. And that should be it.

Now notice this is going to give us items properties instead of programmer’s property. And if we wanted to change… I don’t want to call this property programmer’s because I want to reuse for my other resources. Now if you do a little bit of magic in the serializer, and I’m going to show you that magic in a few minutes, you could make this dynamic. You can make programmers for programmers, and battles for battle entities. But instead, I’m just going to keep items which is something that you’d usually see with APIs. If they have a key for their collection, they’ll always be called the same thing like items, but they’re not whether you’re returning a collection of
programmers or a collection of battles or something else. Now this means I’ve just changed our API. Assuming that we’re in here that we’re going to look for a programmer’s key that needs to items. So I’ll search inside of our test here, and there we go. 

Now using this is pretty simple.

$paginatedCollection = new paginatedCollection(

I’ll pass the items which are programmers.

$programmers,
$pagerfanta->getNbResults()
);

And for creating APIResponse we’ll, just pass in that paginatedCollection

$response = $this->createApiResponse($paginatedCollection);

And with any luck, courses that still fail, we want them to fail the same part where it actually fails just because we don't have the links in there yet. And yeap, looks like… yeap in the areas that couldn’t really populate links and our response looks awesome up here. Looks awesome. Okay so, let’s start adding some links.
