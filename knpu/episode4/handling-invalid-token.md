# Handling Invalid Token

We already know that if an anonymous request somehow makes it to our controller, and then get kicks out, that the start method is [inaudible] [00:00:11], the entry point.  This is our opportunity to invite the user to send authentication on the next request.  But what happens if authentication fails?  I mean, we send a token that is bad.  Well, to find out, let’s copy test Requires Authentication, paste it, and rename it to test Bad Token.  In this case, we will send a headers key, and we will send an authorization header, and we will send it to Bearer WRONG.  When this happens, the status code we want is a 401.  So, that’s good.  But, like always, we’re going to want application/ problem+json response header.  We basically can add this to every 400 level responses.  We always want to have this format.  

I won’t worry about checking any other fields, but I do want to make sure that we at least get that header back.  So, when we fail authentication, what handles that?  Well, the answer is the onAuthenticationFailure method inside of your authenticator.  You see, what happens is the getUser method must return a user object.  If it does not return a user object, then onAuthenticationFailure is called.  In our case, there are two reasons that might happen.  One, the token might not be decoded correctly, either because it’s just a completely invalid token, or maybe it’s expired. Or second, it’s possible that even if the token is decoded, that maybe somehow the username doesn’t exist in our system somehow.  But either way, if a user object is not returned from getUser, authentication fails, and we call onAuthenticationFailure.

So, for now, let’s just return a new response that just says Hello, and we’ll make that it has that 401 status code.  So, copy the test Bad Token method name, go over and run ./vendor/bin/phpunit –filter, paste that name, and there we go.  It almost works.  It gets past – it does have the 4 … it does pass our test for a 401 status code, but it fails because, of course, we don’t – we’re not returning the proper application/ problem+json thing.  So, that’s simple enough.  We’ll do the same thing as before and create a new api problem.  So, $apiProblem = new ApiProblem and we’ll pass that the 401 status code.  And then $apiProblem–>set and we’ll give it that same detail field.  And in this case, that Authentication Exception, that hint about what went wrong, is always passed to it, because we always have some information about what went wrong.

So, we can use its handy getMessage key to get safe message.  And, by the way, if you want to you can translate that key into other languages.  That’s totally allowed.  And finally, we’ll return $this–>responseFactory–> and we’ll reuse that to turn apiProblem into a nice apiProblem Json response.  And that’s it.  We’ve done all of the hard work already before.  So, just to see what this [inaudible] looks like, at the bottom of test Bad Token, let’s add a debug Response, because I think this test is going to pass and I want to see what it actually looks like to believe that it’s passing.  So, rerun the test.  And all green.  And you look at it, it looks awesome.  It’s got the application/problem+json, and it has all of the typical fields we have, like status, title, and notice detail, invalid token.  

That is coming from our code, where we throw a CustomUserMessageAuthenticationException, which ends up being our Auth Exception, which gives us that nice message key.  So that’s it, guys.  jwtAuthentication is actually pretty straightforward.  Give the user a way to somehow get the token and then add a guard authenticator to check that token on every request.  We had to do a couple things to make sure that we were handling the errors really nicely, but now we have a really robust system to handle whatever we want.  Now, a couple of things I do want you to think about that you might want to use in your situation.

First, when we created our jwt, we put the username inside of it, which made it very easy later to load that user from the database, but you don’t have to do this.  You could, for example, put any information inside your token.  In fact, you could just include scopes, like OAuth scopes, in your token.  Or another way to describe that is role.  You could actually put the roles inside of your token.  No one says inside of your authenticator that you need to even be able to identify who the user is that the token belongs to, or that you need to load the user from the database.  If you wanted to, you could decode that token and create a new user object, not an entity that’s persisted into the database, but a new user object and populate it based on the data that you put inside of that token.  

So, these are things to think about.  Not everybody issues tokens that have a one-to-one relationship with a user.  Sometimes tokens are more like a package of permissions that we can then decode on the server to figure out what the user can and cannot do.  Another thing to think about is OAuth.  Which, you remember, OAuth is just a mechanism for delivering a token securely to your client.  So you may or may not need OAuth in your application.  If you’re not sure, you can watch our screencast on OAuth to figure out how it works and whether or not you might need it.  And the last thing is refresh tokens.  You might remember from the beginning of the tutorial that when we set up jwtAuthentication, we gave our tokens a time to live of six hours.  

So, these jwt tokens don’t last forever and they’re not supposed to.  However, sometimes when the original token is sent back, the api decides to also send back a refresh token, which is something that lives forever.  And the idea then is that at any time in the future, the user could then be refresh token back to the api and we would deliver then a fresh Json web token that they can use to access.  It’s not something I want to talk about here, because it’s kind of an edge case, but if you’re thinking about how can I make my tokens permanent, look into using refresh tokens.  

All right, if you have any questions, let me know.  This stuff can be very confusing.  Don’t overcomplicate it though.  And as always, I’ll see you guys next time.
