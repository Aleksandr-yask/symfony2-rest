# Auth API Problem

The real great [inaudible] is how well we’re handling our errors.  Whenever anything goes wrong, you get back this really nice application problem plus JSON content type with these very specific feels that tells us about exactly what’s going wrong.  So I want to do the same thing when something goes wrong with authentication; keep this very, very nice system that we have going.  Open up the token controller test.  And down here when we send invalid credentials, remember that actually hits our token controller, and then we throw this new bad credentials exception and that kicks us out.

So it turns out that this also triggers the entry point inside of our authenticators. This also triggers the start method inside of our JWT token authenticator.  And if you think about it, that makes sense.  Any time an anonymous user is able to get into your application and then you throw an exception from within your controller to deny access, that’s going to trigger the entry points.  And of course the entry point right now is just returning a simple JSON response; it’s not our very pretty applications last problem plus Jason stuff so I want it to be.  So I'm going to copy the last four lines from one of the test and program controller test and let’s add that to our test post token invalid credentials.

The header should be application/problem plus JSON.  The type is going to be about corn blank.  That’s what we use when we have kind of generic errors that are just related to the status code, so in this case the 401 status code.  Then the official – the title that should be used for the 401 is unauthorized.  And I'm just getting that from our API problem class itself.  One of the things it does is when you pass in the type – in this case the about blank – it actually looks up the status code and looks for the official title of the status code.  So the 401 status code means unauthorized.  So it’s going to automatically look that up behind the scene and it’s going to be really cool.

And then for detail, which is an option field, we’re going to make this invalid credentials with a period.  And I will show you why in a second.  But first, we know that this triggers the JWT token authenticator.  So let’s make a proper API problem here.  So dollar sign API problem equals new API problem; that’s the helper class that helps us with this stuff, and it will be a 401 status code and we won’t pass a type in.

Next for that details cue which is optional, you’ll notice when the start method is called, sometimes there’s an off exception that’s passed to it.  Don’t worry too much about that but basically know this.  Sometimes when you end up with the start method, you actually know the reason why.  And in fact, that’s what’s happening inside of our token controller.  Because we’re throwing this bad credentials exception, that’s actually hinting to our authenticator what went wrong.  And if you hold command and look inside of this class, you’ll see that it has a get message key of invalid credentials period.  And you’ll notice that’s what I added inside my token credentials task.  In fact, make sure yours matches – your task matches that key exactly.

So without going into the detail of the security system too much in this tutorial, the basic idea is that inside of your start method, if you’re past a auth exception, the authentication exception is a special class; it has a get message key method on it, and you can use that to get a safe message to show the user.  So in this case, because we threw in the bad credentials exception, we’re going to have a safe key of invalid credentials.  So down below API problem equals new API problem, add message equals auth exception, question mark, auth exception error get message key, colon – we’ll just say missing credentials.  Because we’re not always past an auth exception.  If we’re not past one, we just know that no credentials were passed to us and we don't have any more information about that.  And then we’ll set API problem arrow set, and we’ll add a new details property to things.  Okay?

So the moral of the story is that in the start method, you might have information about what went wrong to end up here, or you might not.  Finally, let’s return a new JSON response with API problem 2RA and then a 401.  Perfect.  Well, not quite perfect but it’s going to get closer.  So copy the token controller test method.  Let’s go back and run vendor vin peach P unit, dash dash filter and then paste that method.  And you can see it’s pretty close.  It looks like we want but we’re still getting the application slash JSON instead of the application slash problem plus JSON header.  So that’s no problem; we just need to set the header inside of our start method.  But wait, don’t do that.  Because we have done all of this work before.

In the event list in our directory, there’s an API exception subscriber.  This is something that handles all of the exceptions that are thrown under the slash API UR honor application, something we made in a previous tutorial.  And it already has all of the logic we need to turn an API problem object into a response.  So what we really need to do is centralize this code so we can reuse it here, and inside of our authenticator.  So copy the last ten lines or so out of the API exceptions subscriber.  And the API directory, let’s create a new class called response factory.  And inside there, a new public function called create response.  We will pass it in API problem and it will take care of all of the logic for turning that into our proper JSON response.  And I will auto complete on JSON response to get the U statement.  Perfect.

Next, it’s going to service as that YML and register this as a service.  So API dot response underscore factory, set the class to response factory and there are no arguments so will leave that blank.  And we already know we’re going to need this inside of our API exception subscriber so I'll add a second argument here, which will be at API dot response factory.  Perfect.  And then in API exceptions subscriber, you can add a second constructive argument for the response factory.  I use the option enter shortcut to initialize that field.  That just adds the property for me.  And then down below, very simple, response equals this arrow, response factory arrow, create response, pass it the API problem.  Easy.

And now, a last step we can celebrate by using this inside of our JWT authenticator and it will take care of some of the logic for us.  So same thing.  I'll add a third argument in this case for a response factory, and I'll use the same shortcut, option enter, to initialize the field.  That added the property for me.  Looks good.  And then down below, instead of creating the response by hand, it’s a return this error response factory, arrow great response and pass it, our API problem and that’s it.  And I don’t need to update the services dot YML for the authenticator because you’ll remember; we’re using auto wiring so it’s going to take care of adding that third argument automatically for us.  

So if everything went well, should be able to rerun a test.  And it fails, but let’s see, here.  You see some problems about get detail, detail?  Neither the property detail nor one of the methods is there.  Error reading property detail from available keys details; that sounds like a Ryan mistake.  Open up your token controller test and make sure that this key is called details.  And here we’re looking for detail, and that was actually correct.  Inside of my JWT token authenticator, change that key to detail.  That key can really be anything but detail is a service standard field that’s often used.

So rerun that test.  That looks perfect.  In fact, if we rerun our entire test suite, we didn’t break any of our exception handling.  Awesome.  So the only error situation that we haven’t handled is what happens if somebody sends a bad JWT?  Or, for example, it’s been corrupted or maybe it’s just expired.  So let’s try that next.
