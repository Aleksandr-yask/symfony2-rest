# Entry Point Multiple Firewalls

The authentication system works great, except what happens when it doesn’t work. So, right now, in this test we’re not sending an authorization header.  And, for some reason, we’re getting redirected to the login page. So, why?  Well, here’s the idea.  If an anonymous user comes into a Symfony application and then tries to access a protected page, Symfony triggers that’s called an entry point.  Basically, they want to invite the user to authenticate.  In a traditional html app, that means redirecting the user to the login page.  But in an api, it means sending back a 401 response code.  So, how do we control this entry point?  Well, if we’re using guard authentication, then you control it with this start method down here.  

So, if an anonymous user comes in the system, tries to access a protected page, then the start method is called – and we can do whatever we want to return a response to the user.  So, let’s return a Json Response, and we’ll just say error, auth required.  It doesn’t really matter for now; we’re going to make this better.  And then the important thing is, we’ll send them back a 401 response code.  Cool.  Copy the test Requires Authentication method.  Let’s run ./vendor/bin/phpunit –filter test Requires Authentication and see if that works.  Huh.  And it doesn’t.  In fact, it didn’t change the behavior at all.  We’re still getting redirected to the login page.  So, what’s going on here?  Well, open up the security.yml file.  Here’s the problem.  We have a single firewall.  So, a single security system for our application.  

When an anonymous user comes into our site and hits a page that requires access, Symfony has to figure out what one thing to do.  So, if this were an html web app, we would want to redirect to the login page.  If this were an api, we’d want to return a 401 response.  But this app is a mixture.  We do have html pages and we do have api pages, so Symfony doesn’t really know what to do.  The form_login authentication mechanism has a built-in entry point, and right now it is taking priority.  So, even though we have our cute little start function here, Symfony is using the start function, the entry point from the built-in form_login authenticator.  Now, we can control that.  You can actually specify an entry point key into your firewall and say no, no, no, I want to use this service as my entry point and we can point to our authenticator.  

But then that would break our html app, because we still want to redirect to the form for all of our html pages.  So, I’m a big advocate of having just a single firewall, but this is a case where we need to split into two firewalls.  We really have two very different authentication systems.  We have an entire half of our site that uses form_login and html pages and we have a whole second half of our site that uses api authentication and a whole different set of controllers and routes for all of that.  So, let’s split this up into a second firewall.  Above, the main firewall, we’ve got a new key called api.  The name of that is not important.  And set pattern: ^/api/.  That’s a regular expression, so it’ll match anything starting with /api/.  And when Symfony boots, it only matches one firewall from top to bottom.

So, if we go to /api/ something, it will match only the api firewall.  Everything else will match the main firewall, which is exactly what we want.  Let’s still allow anonymous access, in case we want it.  And now that we have two firewalls, I’m going to add a stateless: true.  This is kind of cool because it tells Symfony that in this firewall, don’t try to store the user and the session.  We have stateless users who are using api tokens.  That’s not a requirement, but now you can have that and it’s cool.  And then I will move our guard authenticator up into our api firewall.  And that should be it.  Now, it will use our start method from our authenticator instead of using the one from form_login, and we should be good.  So, let’s give it a try.

We run the test.  And it works.  So, don’t jump to having two firewalls necessarily, but if you have a very separate site between the html and the api like we do, then go ahead and create a second firewall.  
