# JWT Guard Authenticator

For our authentication system, we’re going to use guard.  I’m just going to make it really fun to set all this up.  [Inaudible] [00:00:08] the screen.  And in AppBundle grab new security directory.  And then assign a new PHP class called jwtTokenAuthenticator.  Now, all authenticators always start the same way.  We’re going to extend the AbstractGuardAuthenticator class.  And then I’m going to go to the code it generates menu, or command-M on a Mac.  And go to implement methods, and I’m going to implement all the methods that I need to.  And then I’ll go back and do that one more time to get the start method.  I’ll keep that one on the bottom.  Okay, great.  So, let’s walk through the process of guard authentication and if you’re new to guard authentication, we have separate tutorials about that, so go check those out.  But it’s pretty simple.  

So, get credentials – our job is to get the credentials off of the request and in Api, the credential is the Api token.  So, all we need to do is read that authorization header and then do a little string parsing because we have the bearer being sent along with it.  The jwt bundle actually comes with a helper for that, so we can say $extractor = new AuthorizationHeaderTokenExtractor and then we pass it the word Bearer, that’s our prefix, and then the name of the header, which is Authorization.  And then that will get the token for us by saying $token = $extractor–>extract, and we just pass it the request object.  So, [inaudible] take care of all that stuff for us.  And now, if there is no token, just return null, and then that will cause authentication to stop.  Not fail, just stop.  Because there is no authentication information being sent on this request.  

And we’re going to talk a lot more about what happens next.  So, what happens if there is no token sent, but the page requires a token.  But for now, we need our authentication to just quit.  Now, if there is a token, let’s return that. Perfect.  So next, if we return something from this method, that token is passed to getUser as credentials.  Our job is to use that token to find the user that relates to that token.  And here’s the cool thing about JSON web tokens.  Remember, our token contains information.  It contains the username.  So, we’re going to be able to actually JSON decode that token, and then get this information right back out of it and we’ll use that to query for the user.  Now, in order to do that, we’re going to need two services.  So, I’m going to go back to the top of this class and make a construct function.  And we are going to need the lexik encoder service again.  

So, I’ll go back and run ./bin/console debug: container lexik, and then select the jwt authentication encoder.  And you can see this is just an alias for the first one.  So, I’ll run that command again.  And this tells me what class it is – jwt encoder.  So, I’ll type in my argument with JWTEncoder.  Now, actually as I do that, you can see there is also an interface, which I’m guessing that class implements.  So, let’s try to use the interface instead.  $jwtEncoder, and then I also need the EntityManager, so we can query for the user object, $em.  Now, I’ll use a shortcut on [inaudible] storm, which is option enter on a Mac, to initialize those fields.  And all that did is create the two properties up to and assign them down in the construct function.  So, you could just do that by hand if you wanted to.  

Okay, down in getUser, step 1.  We need to decode that token.  So, say $data = $this–>jwtEncoder, and it’s super simple.  It’s decode and then pass it credentials, which, remember, is our token string.  And that’s it.  It takes the token string and decodes it into plain data.  Just like a normal JSON encode.  Behind the scenes, when it does that, it’s checking two things: it’s checking first that package of information hasn’t been tampered with, and it’s using the private key on our side to make sure that no one has messed with anything.  So, we can guarantee that nobody has changed the username to be some other username to gain access so the site.  It’s also checking and expires, because we set a maximum time of six hours in our config.yml file, so if the token’s expired, it will also fail at this step.

So, if $data === false, then we know that there’s a problem with the token, and so we can throw a new CustomUserMessageAuthenticationException of Invalid token.  And again, we’ll talk more about error handling in a second.  But assuming everything is good, we have a username.  $username = data[‘username’].  And now, we’re simply going to query for that.  $this–>em, –>getRepository(‘AppBundle:User’), –>findOneBy([‘username’]) set to that username, and that’s it.  If that’s a valid username, that will return a user object.  If not, authentication is going to fail.  And that’s it, guys.  In checkCredentials, the token itself is credentials.  You can just return true for this, so that doesn’t fail.  

We’re going to talk about onAuthenticationFailure in a second.  And onAuthenticationSuccess, just do nothing, because we want the request once it’s authenticated to continue to the controller, so that our controller can do the normal work.  Then for supportsRememberMe, this is not important at all, so just return false.  And we’re going to talk about start method in a second.  But really, you just need to have getCredentials and getUser filled in.  Now, once this is done, go into app config services.yml, and let’s register this as a service.  How about jwt_token_authenticator.  Give it a class of jwt token authenticator.  

And, instead of the arguments, I’m actually going to be lazy and just autowire those arguments.  That’s a new feature in Symfony 2.8 that works most of the time.  But you could specify the arguments manually like the service above it, if you wanted to.  The last step is to copy that service name.  Go to security.yml, add a new guard key.  Authenticator is keyed below that and then paste that service in.  As soon as you do that, on every request in Symfony, our token authenticator is going to be looking for the authorization header and it should just work.  So, go back, let’s run our original testPOSTprogrammer as it exists, and this time, with any luck – it passes.  Which is maybe more amazing than you realize.  

This means our system is actually decoding that token.  It is actually authenticating the user, so that in ProgrammerController, when we asked for to make sure that the user is authenticated, the user is authenticated.  In fact, there’s one other spot we can fix.  Down on line 37, we’ve so far been hard coding it so that every new programmer is automatically owned by weaverryan.  Well, that’s not what we want anymore.  We want whoever the user is for the token that was just sent.  So, that’s simple enough.  We can replace it with $this–>getUser, and that’s it.  Our controller can’t tell how we were authenticated.  It doesn’t care that it was authenticated via jwt_token.  It just cares that somebody is logged in.  

So, run the test again.  And it passes.  And if you don’t believe me, you can run ./bin/console doctrine: query: sql ‘SELECT * FROM battle_programmer, the name of our table.  And we’ll add a –env=test to use the test database.  And there’s our one programmer that was just created, who’s related to user ID of 58, which I’m guessing is our user.  There it is.  So, welcome to our beautiful jwt authentication system.  Now, let’s lock down our entire api to require users.
