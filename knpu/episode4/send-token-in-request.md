# Send Token in Request

Remember when we started, we already add this deny Access Unless Granted to our new programmers action.  So, the new programmers action is broken right now because we don’t have an authentication system hooked up yet.  In fact, if we open Programmer Controller Test and go up to test POST and actually we can run this.  Actually, rename that to test POST Programmer Works.  That’ll make it easier because we can just copy that method name.  And then run ./vendor/bin/phpunit –filter, and we’ll only run that one method.  So, perfect.  Instead of a 201 status code, we get the 200 status code, because it’s redirecting us to the login page.  So, we don’t have our security system hooked up yet, but we do have a way to create a token.  So, what I want to do is update this test so that we’re sending the token up to our server.  

So, the first thing we need to do inside of our test is grab a token.  And we can do that by saying $token = $this–>get Service, which is a shortcut we have set up to get a service out of the service container.  And we can just get a token the same way we did a second ago in the token controller.  Grab the lexik authentication encoder and then just call it encode and pass it username, weaverryan.  So there we have the token.  So, now how do we send the token to the server?  Well, we can do whatever we want because we’re creating the Api.  We can put it as a query [inaudible] [00:01:45] or we can add it as a header.  The most common thing is to add it on an authorization header.  So, then on the guzzle call, add a headers key and create one called Authorization and set its value to Bearer. $ token.  

That’s a really standard way to send a token up to an Api.  And that’s it.  If we rerun the test now, it’s of course still failing, but now we’re set up.  The last step we need to do is create an authentication system that looks for that token and logs in our user. And as soon as we do that, this test is going to pass.  
